`cat [file1] [file2] ...` - Вывод содержимого файла в окно терминала

`ls` - выводит содержимое данной директории, можно указать конкретный путь если надо.
Основные флаги:
- `-l` для подробного вывода
- `-F` для отображение информации о типе файла
- `-a` для отображения всех файлов и директорий даже скрытых

`cp [file1] [file2]` - копирование `file1` в `file2`, можно так же копировать в директорию например `cp [file1] [dir]`, а так же несколько файлов в директорию `cp [file1] [file2] [file3] [dir]` .

`mv [file1] [dir]` - почти тоже самое что и `cp` , если `file1` не существует он его создаст, если вторым аргументом передать тоже файл то второй файл переименуется.

`touch` - создает файл. Все))) (ну ладно еще обновляет таймер создания файла если он уже есть)

`rm [file]` - удаляет файл.

`echo [some]` - выводит содержимое переменные или текст в консоль, в основном используется для разного вида поиска. Например: `echo *` выводит список файлов и директорий находящихся в текущем каталоге. `echo at*` - выводит файлы начинающиеся на `at`. ну и разные комбинации, смысл надеюсь ясен, шаблоны для поиска можете погуглить если что.

`cd` - перейти в указанный каталог. Без аргументов перекидывает в домашнюю директорию. Подняться на один каталог наверх `cd ..`, на два `cd ../..` и т.д. 

`mkdir [dir] ` - создает новый каталог.

`rmdir [dir]` - удаляет каталог, если в каталоге есть файлы или другие каталоги, то потребуется флаг `-r` для рекурсивного удаления. Ну и 10 раз подумайте прежде чем ее юзать, так как восстановить потерянное будет нельзя.

`grep` - выводит строки из файла или потока ввода соответствующие указанному шаблону. Очень сильная команда, если вы умеете писать регулярные выражения.
Основные флаги:
`-i` - для поиска без учета регистра
`-v` - для инвертированного поиска 

`less` - Выводит содержимое файла постранично, используется для просмотра больших файлов, нажать `Пробел` - можно перейти на страницу вперед, `b` на страницу назад, `q` выйти.

`pwd` - выводит путь текущей директории. Полезно когда в пути есть *symlink*, так как не всегда из за них понятно где находится рабочая директория, для того чтоб узнать оригинальный путь нужно добавить флаг  `-P`.

`diff [file1] [file2]` - нужна чтоб увидеть отличия двух текстовых файлов. 

`file` - команда для определения сможет ли система распознать данный файл.

`find` и `locate` - `find [dir] -name [file] -print` найдет файл в указанной директории с указанным названием. Возможностей у этих команд много, но в основном поиск вы будете использовать так, а так проще посмотреть документацию, чтоб не повторяться по 10 раз.

`head` - Выводит первые 10 строк файла, можете указать свое число строк которое вам нужно, по типу `head -5` 

`tail` - то же что и предыдущее только с конца. Еще можно вывести с определенной строки например: `tail +10` которая выведет содержимое с 10 строки.

`sort` - сортирует строки текстового файла в алфавитно-цифровом порядке, для сортировки в числовом порядке нужен флаг `-n`, `-r` сортирует в обратном порядке

Так же результаты выполнения команд можно выводить прямиком в файл, например:
`command > [file]` сохраняет вывод в указанный файл. Если вы повторно запишите вывод в тот же файл, то он перезапишется.
Для добавления информации в файл нужно использовать `>>` .

`cmod` - может менять [[Общая картина#Режим файлов и права доступа|права доступа]] к файлу. Так мы можем с помощью сумм битов выдавать абсолютные режимы прав доступа. Так например:
`chmod 644 [file]` Дает разрешение следующие:
- Пользователь - чтение и запись
- Группа - только чтение
- Остальные - только чтение
Числовая нотация состоит из трех цифр, где каждая цифра представляет разрешения для владельца, группы и остальных пользователей соответственно. Каждая цифра состоит из суммы разных значений, присвоенных разным разрешениям:

- 4 — разрешение на чтение (read).
- 2 — разрешение на запись (write).
- 1 — разрешение на выполнение (execute).
- 0 — отсутствие разрешения.

Для установки конкретных разрешений, сложите соответствующие значения:

- Если вы хотите только разрешение на чтение, используйте 4.
- Если вы хотите разрешение на чтение и запись, сложите 4 и 2, что даст 6.
- Если вы хотите разрешение на чтение и выполнение, сложите 4 и 1, что даст 5.
- Если вы хотите разрешение на чтение, запись и выполнение, сложите 4, 2 и 1, что даст 7.

Вот таблица для лучшего понимания:
![[Pasted image 20240621004333.png]]
## Перечисление процессов и управление ими
Данную тему лучше выделить в отдельный подзаголовок, так как тут много чего.
`ps` - выводит таблицу запущенных процессов.
Вы увидите что то типо такого:
```
PID   USER     TIME  COMMAND
    1 root      0:00 {init(docker-des} /init
    6 root      0:00 {init} plan9 --control-socket 5
    9 root      0:00 {SessionLeader} /init
   10 root      0:00 {Relay(11)} /init
   11 root      0:00 -ash
   17 root      0:00 ps
```

`PID` - идентификатор процесса
`USER` - пользователь который запустил процесс
`TIME` - количество процессорного времени которое процесс успел использовать, то есть общее время которое было потрачено процессором на выполнение данного процесса.
`COMMAND` - команда используемая для запуска программы. 

Теперь посмотрим на параметры:
`ps x` - отображает все запущенные вами процессы
`ps ax` - выводит все запущенные процессы а не только ваши
`ps u` - выводит более подробную информацию о процессах
`ps w` - выводит полные имена команд

 Попробуем ввести побольше инфы:
```
# ps au
USER       PID %CPU %MEM   SZ  RSS    TTY STAT    STIME TIME COMMAND
root     19048 24.6  0.0   28   44  pts/1 R    13:53:00  2:16 /tmp/cpubound
root     19388  0.0  0.0  372  460  pts/1 R      Feb 20  0:02 -ksh
root     15348  0.0  0.0  372  460  pts/4 R      Feb 20  0:01 -ksh
root     20418  0.0  0.0  368  452  pts/3 R      Feb 20  0:01 -ksh
root     16178  0.0  0.0  292  364      0 R      Feb 19  0:00 /usr/sbin/getty
root     16780  0.0  0.0  364  392  pts/2 R      Feb 19  0:00 -ksh
root     18516  0.0  0.0  360  412  pts/0 R      Feb 20  0:00 -ksh
root     15746  0.0  0.0  212  268  pts/1 R    13:55:18  0:00 ps au
```

`%CPU` - использование времени процессора в процентах
`%MEM` - использование оперативной памяти в процентах
`SZ` - размер процесса в памяти, Кбайт
`RSS` - размер процесса в памяти, Кбайт
`TTY` - терминал, из которого запущен процесс
`STIME` - время запуска процесса
`TTY` - состояние процесса, например `S` означает что процесс приостановлен, `R` что он запущен

`kill` - завершает процесс. В аргумент нужно указать либо `PID` либо название процесса, но лучше использовать именно первое. Если добавить флаг `-STOP` то процесс просто остановиться, продолжить его можно с помощью флага `-CONT` .
Так же можно отправить принудительный сигнал `-KILL` или можно `-9`. Процесс завершится в любом случае. Выглядит это так `kill -9`, но лучше быть осторожным когда выполняешь такую команду, и хорошо осознавать что ты делаешь.

### Фоновые процессы
Обычно запустив команду в терминале мы не можем запустить что то еще, так как терминал будет ожидать завершение запущенной команды.
Поэтому у нас есть возможность запускать процессы в фоне с помощью `&` . Например:
`gunzop file.gz &` Операция запустится в фоне и мы сможем работать в терминале дальше и не ждать результата данной команды. Но стоит думать опять же перед тем как запускать некоторые команды в фоне, так как там могут требовать дополнительный ввод от пользователя и т.д. из за чего процесс может повиснуть в фоне и просто занимать ресурсы процессора. Но если возникнут проблемы, мы можем вернуть запущенную команду в фоне обратно в оболочку командой `fg`. 

## Символические ссылки
**Символическая ссылка** - это файл, который указывает на другой файл или каталог, создавая его *alias*. Такие ссылки обеспечивают быстрый доступ, скрывая пути каталогов. 
`ln -s target linkname` - синтаксис следующий. собственно `-s` и говорит нам что ссылка будет символическая, без этого флага у нас будет жесткая ссылка, которая добавляет дополнительное реальное имя файла к новому файлу.
