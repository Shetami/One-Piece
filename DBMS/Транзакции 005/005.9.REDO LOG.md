Здесь логика именно в повторении транзакций. 
Повторяются транзакции для которых есть **COMMIT**, тк если коммита нету - то они и записать ничего не успели (тк запись идёт только после **COMMIT**)

В отличии от UNDO - логирует new_value. 

Эта стратегия, но улучшенная каким то образом в посгресе.

Если было инициализировано синхронизация(в WAL файлы на диск), но коммита нет, то поставить ABORT, типа транзакция валидна
# Правила записи
- Сканируем от старых до новых записей.
- **COMMIT** в журнал на диск происходит тдо того, как данные фактически из оперативки прыгнут на вторичку. 

![[Pasted image 20240625183423.png]]
**WriteLog** - перенесёт **COMMIT T1** из оперативки журнала в журнал на диске.
# Восстановление
- Составляет 2 группы. С **COMMIT** и ABORD/незавершённые.
- Повторяет те, для которых есть **COMMIT**

# Checkpoints
- В журнал добавляется `START CHKn: Tn,…,Tm` , фиксируется на диске через WriteLog
- Сохранение всех грязных страниц на диск, изменённых транзакциями на момент `START CHKn: Tn,…,Tm` . То есть транзакции до `START CHKn: Tn,…,Tm` уже сохранены.
- `END CHKn` добавляется в журнал, фиксирутеся на диске через WriteLog

##### Восстановление
- Надо всегда проверять **Tn,...,Tm** (те, которые были активны на момент **START**). Чтобы их проверить надо зайти в глубь и посмотреть закончились ли они.

# Недостаток
- Обратный **UNDO** - нельзя сбросить на вторичку данные до завершения транзакции (записи  в WAL вторички) => нужно много памяти под буферы памяти.
