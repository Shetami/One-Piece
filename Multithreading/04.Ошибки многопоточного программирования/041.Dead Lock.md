1. Двойной захват на нерекурсивном mutex в одном потоке (вопрос на собесе часто задают)
2. fork, где mutex уже залочен. Поток, инициировавший fork будет вечно ждать mutex, тк некому освободить ресурс.
   
   Fork делает полную копию с адресным пространством.
   ```
   if (fork()){ // возвращает индентификатор дочернего процесса
   
   }
	```
	В форкнутом процессе будет 1 поток, являющийся главным.
	
	Чтобы избежать этого - используем функцию **pthread_at_fork(1, 2, 3);** . Вызываем до **fork()**. Регистрирует обработчики, которые выполнятся при команде **fork()** .
	После **fork()** продолжаетс код после этой команды. Переносится именно 1 поток для предсказуемости, тк в проитвном случае другой поток мог бы подписнуть. 
	1 - функция, выполняющаяся врамках первого процесса, до того как был сделан **fork()**.  В ней захватывают все ресурсы + ещё ченить. Захват происходит очевидно так, что мы встаём в очередь, пока все не освободят ресурсы, которые мы хотим захватить.
	2 - функция в рамках первого процесса после **fork()**.  Освобождаем ресурсы + ещё ченить.
	3 - функция в рамках второго процесса после **fork()**. Освобождаем ресурсы + ещё ченить.
3. Класический перекрёсный захват.
   ```
	m1.lock()
	m2.lock()
	```
	```
	m2.lock()
	m1.lock()
	```