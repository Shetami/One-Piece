|w|r|r|r|w|

Работает как `read_write_lock()`
если доступ к данным осуществляется только на чтение с нескольких потоков - то разрешит доступ всем, если кто то пишет, то не даст доступ другим

`lock()`
`try_lock()`
`unlock()`
`timed_lock()`
`[timed_d]lock_shared()` Захват на чтение
`lock_upgrade()` Захват на чтение, с возможностью дозахватить на запись. Читатели смогут работать вместе с тем потоком кто  вызвал `lock_update()`, но когда кто-то вызовет `lock_write()` на дозахват на запись, то после этого уже никто не сможет продолжить.

###### Нарушение инварианта
```
f(){
	m.lock_read();

	if(invariant){
		m.unlock();
		//на этой строчке может прийти тысяча других потоков и оттарабанить структуры и чё у нас есть, то есть инвариант в устловии будет уже другой, не тот, который предполагался для логики после некст захвата (некст строка)
		m.lock_write();
	}

}
```

###### Решение проблемы с помощью дозахвата

```
f(){
	m.lock_upgrade();

	if(invariant){
		m.ulock_wire(); //сразу дозахватываем, не давая другим алгоритмам чёто разъебать
		//logic
	}

	m.unlock();
}
```
