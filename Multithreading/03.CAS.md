`compare_and_set(old_var, predict_value, set_value)`

принимает адрес переменной, предполагаемое значение, то что хотим чтобы было.
предполагаемое сравнивается с тем что там сейчас лежит. Если окей то засовывается то что мы хотим

Ебашит за 1 такт операцию атамарно, чтобы никто не пришёл и не разъебал нам всё пока мы сравниваем и устанавливаем.

Не впадаем в **kernel space**

###### Пример CAS инкримента

```
for (;;){
	int current = get();
	int next = current + 1;
	
 //тут на CAS могут встать сразу несколько потоков, один сможет ебонуть, а остальные откинутся дальше крутиться в цикле и пытаться.
 
	if (compare_and_set(current, next)){
		return next;
	}
}
```
###### Преимущества
1. Шанс того, что потоки будут конкурировать на mutex, гораздно выше, чем проебутся на cas. Потоки не прсотаивают то есть.
2. Не падаем в ядро да
3. Программа всегда прогрессирует так что окей
4. Не увеличиваем последовательный код. (не параллельный)