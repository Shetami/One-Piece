#c_plus_plus 

`pthread_create(*func)` 
`pthread_join(*thread)`  
блокирующая.

 Системные вызовы и приводят к смене контекста.
 И то что на `pthread_`
 ---
 ##### Структура thread
 Из интересного:
 флаг должен ли завершиться
 флаг должен ли за завершиться, если его хотят завершить (дополнительный флаг, чтобы поток мог сам не разрешать себя завершать)
---
##### Завершение потока
 `pthread_cancel(thread)` устанавливает в поток флаг, что надо бы закончиться.
 Сам поток иногда проверяет флаг и закончится только тогда, когда проверит.

Чтобы завершиться поток иногда вызывает `pthread_test_cancel(),` чтобы проверить нужно ли завершить себя. 

ОС выдаёт ошибку если пытаться завершить поток не своего процесса
###### Последние слова
`pthread_cleanup_push(*func)`
`pthread_cleanap_pop(*func)` 
Методы, чтобы сделать предсмертные действия, типа сообщить другим потоком о неминуемой гибели/освободить ресурс
Эти методы регистрируют методы для освобождение ресурсов
Перед смертью это дело всё вызывается.

Хорошей практикой является прописывает `pthread_cleanup_push(*func)` после mutex

Те функции, в которых вызывается `pthread_test_cancel` называются **cancellation points** (точки останова потока).  Почти все системные вызовы: sleep, ввод/вывод... Это нужно, чтобы если мы входим в функция - имели возможность там тоже завершить поток. Прописывать его нужно внутри потока.
В зависимости от бизнес логики нужно или не нужно их расставлять, так как бывают кейсы когда мы не хотим, чтобы нас могли завершить снаружи.
`pthread_test_cancel` вызывает смену контекста, так что если есть долгий цикл, то ставить к примеру раз в тысячу итераций.