`pthread_create(*func)` 
`join(*thread)` waiting

`pthread_join(*thread)`  блокирующая.
 Системные вызовы и приводят к смее контекста.
 И то что на `pthread_`
 ---
 ##### Структура
 Из интересного:
 флаг должен ли завершиться
 флаг должен ли за завершиться, если его хотят завершить (дополнительный флаг, чтобы поток мог сам не разрешать себя завершать)
---
##### Завершение потока
 `pthread_cancel(thread)` устанавливает в поток флаг, тчо надо бы закончиться.
 Сам поток иногда проверяет флаг и закончится только тогда, когда проверит.
 Флаг устанавливается вроде не блокирующе.

Чтобы завершиться поток иногда вызывает `pthread_test_cancel(),` чтобы проверить нужно ли завершить себя. 
###### Последние слова
`pthread_cleanup_push(*func)`
`pthread_cleanap_pop(*func)` 
Методы, чтобы сделать предсемертные действия, типа сообщить другим потоком о неменуймой гибели/освободить ресурс
Эти методы регестрируют методы для освобождениев ресурсов
Перед смертью это дело всё вызывается.

Хорошей практикой является прописываеть `pthread_cleanup_push(*func)` после mutex

Те функции, в которых вызывается `pthread_test_cancel` называются **cancellation points** (точки останова потока).  Почти все системные вызовы: sleep, ввод/ввывод... Это нужно, чтобы если мы входим в функция - имели возможность там тоже завершить поток. Прописывать его нужно внутри потока.
В зависимости от безнес логики нужно или не нужно их расставлять, тк бывают кейсы когда мы не хотим, чтобы нас могли завершить снаруже.
`pthread_test_cancel` вызывает смену контекста, так что если есть долгий цикл, то ставить к примеру раз в тысячу итераций.