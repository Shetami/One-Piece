Вам будет предоставлена строка `s` и целое число `k`. Вы можете выбрать любой символ строки и заменить его любым другим заглавным английским символом. Вы можете выполнять эту операцию не более `k` раз.

Возвращает _длину самой длинной подстроки, содержащей ту же букву, которую вы можете получить после выполнения вышеуказанных операций_.

**Example 1:**
```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**
```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achieve this answer too.
```

В чем тут состоит главная задача? Нам бы хотелось понять как отслеживать момент когда мы можем заменить определенное количество символов. допустим у нас есть строка `ABABBA` и нам разрешено заменить два символа. Нам надо нарастить наше *Sliding Wondow* собственно. Для этого мы начнем с самого начала слова. *L* и *R* указатели будут смотреть на первый символ `A`. И нам надо создать условие(я) при которых мы будем контролировать движение наших указателей и соответственно расширение нашего окна. И так для данного примера мы взяли `k = 2`. Воспользуемся этим. Но перед этим лучше разобрать логику с середины. Допустим наш L указывает на нулевой символ, а R на 4, наше окно будет выглядеть так `ABABB`. Так мы видим что мы можем заменить две `A` чтоб наше условие выполнялось. То есть в строке мы имеем 2 `A` и 3 `B`, размер нашего окна равен 5, логично предположить что надо менять значения которых в меньше, поэтому из общей суммы мы логично предположить что нам надо из общего количества символов окна то есть 5 отнять количество наиболее частых символов, то есть 3, $5-3=2$ столько нам надо заменить символов, причем нам не важно что это за символы, `A` или может `C`, так как мы в любом случае должны заменить все оставшееся на `B`. Мы можем менять всего два символа. Отлично, нам как раз и надо поменять два символа. Теперь попробуем расширить окно, теперь оно `ABABBA`. И так количество символов самого часто встречаемого символа до сих пор 3, но окно стало больше. Поэтому $6-3=3$  теперь нам остается заменить 3 символа, но разрешено всего 2, то есть данное окно не подходит по условие, поэтому мы сдвигаем указатель *L* вправо. По ходу перемещения указателей мы фиксируем максимальное значение окна. Логика получается следующая, когда мы двигаем наш *R* указатель, счетчик увеличивается, когда *L* указатель счетчик уменьшается. Вот примерное графическое изображение алгоритма:
![[Pasted image 20240626215339.png]]
Примерно так по итерациям выглядит алгоритм, для хранения количества символов мы используем *HashMap*, откуда мы и будем брать самое честовстречаемое значение в окне.

# Code
- Python
	```python
	class Solution:
	    def characterReplacement(self, s: str, k: int) -> int:
	        count = {}
	        res = 0
	        l = 0
	        for r in range(len(s)):
	            count[s[r]] = 1 + count.get(s[r], 0)
	
	            while (r - l + 1) - max(count.values()) > k:
	                count[s[l]] -= 1
	                l += 1
	            
	            res = max(res, r - l + 1)
	        return res
	```

- Go
	```go
	func characterReplacement(s string, k int) int {
	    count := make(map[byte]int)
	    res := 0
	    l := 0
	
	    for r := 0; r < len(s); r++ {
	        count[s[r]]++
	        for (r - l + 1) - maxCount(count) > k {
	            count[s[l]]--
	            l++
	        }
	        if res < r-l+1 {
	            res = r-l+1
	        }
	    }
	    return res
	}
	
	func maxCount(count map[byte]int) int {
	    max := 0
	    for _, v := range count {
	        if v > max {
	            max = v
	        }
	    }
	    return max
	}
	```