Даны две строки `s1` и `s2`, возвращаем, `true` _если_ `s2` _содержит перестановку_ `s1`_, или_ `false` _иначе_.

Другими словами, возвращает, `true` если одна из `s1` перестановок является подстрокой `s2`.

**Example 1:**
```
Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").
```

**Example 2:**
```
Input: s1 = "ab", s2 = "eidboaoo"
Output: false
```

Нечто похожее часто может встречаться, данная задача чем то похожа на задачу с анаграммой. Нам надо понять как сравнивать строку и подстроку так чтоб каждый раз не проходить по двум строкам с самого начала. Как всегда, если нам надо уменьшить количество проходов в цикле, нам надо запоминать данные, ну и тут выбор либо *HashSet* либо *HashMap*. Так как нам важно количество символов то мы будем использовать *HashMap*. Мы будем отслеживать одну *HashMap* для `s1` и другую для `s2`, и сравнивать, но опять же сравнивать две *HashMap* трудозатратно и нам нужно что то еще. Мы бы хотели отслеживать количество совпадений в какой ни будь дополнительной переменной, назовем ее `matches`. В латинице всего 26 символов, собственно наши *HashMap* будут того же размера. Нам потребуется в первую итерацию пройтись по двум *HashMap* для того чтоб заполнить таблицы, и посчитать стартовый `matches`. Условие будет простым, если количество совпадений будет равно 26 то мы вернем `true`. При каждом изменении *HashMap* мы будем сравнивать текущие символы в двух *HashMap* и обновлять `matches`. Таким образом нам не надо каждый раз проходить по всей *HashMap* ведь мы знаем сколько было совпадений до этого.
![[Pasted image 20240630204004.png]]
Что на картинке, две *HashMap* которые мы заполняем и сравниваем один раз в начале. По `s2` мы проходимся окном размером строки `s1` то есть в данном случае размер 3. У нас на первой итерации 24 совпадения, неплохо, почти 26. Сдвинем наше окно вправо. Тут уже стало хуже. `b` превратилось в 0, и теперь оно не совпадает, появился `y` который нам не нужен и тоже порождает несостыковку с первой строкой. Таким образом если мы дойдем до конца второй стоки там окно совпадет со строкой и наш `matches` станет 26. Надеюсь логика описанная ясна а теперь к коду.

# Code
- Python
	```python
	class Solution:
	    def checkInclusion(self, s1: str, s2: str) -> bool:
	        cntr, w, match = Counter(s1), len(s1), 0     
	        
	        for i in range(len(s2)):
	            if s2[i] in cntr:
	                if not cntr[s2[i]]: match -= 1
	                cntr[s2[i]] -= 1
	                if not cntr[s2[i]]: match += 1
	                
	            if i >= w and s2[i-w] in cntr:
	                if not cntr[s2[i-w]]: match -= 1
	                cntr[s2[i-w]] += 1
	                if not cntr[s2[i-w]]: match += 1
	                
	            if match == len(cntr):
	                return True
	                
	        return False
	```

- Go
	```go
	func checkInclusion(s1 string, s2 string) bool {
	    cntr := make(map[byte]int)
	    for i := range s1 {
	        cntr[s1[i]]++
	    }
	    w := len(s1)
	    match := 0
	    for _, v := range cntr {
	        if v == 0 {
	            match++
	        }
	    }
	
	    for i := range s2 {
	        if count, exists := cntr[s2[i]]; exists {
	            if count == 1 {
	                match++
	            }
	            if count == 0 {
	                match--
	            }
	            cntr[s2[i]]--
	        }
	
	        if i >= w {
	            if count, exists := cntr[s2[i-w]]; exists {
	                if count == 0 {
	                    match--
	                }
	                if count == -1 {
	                    match++
	                }
	                cntr[s2[i-w]]++
	            }
	        }
	
	        if match == len(cntr) {
	            return true
	        }
	    }
	    return false
	}
	```