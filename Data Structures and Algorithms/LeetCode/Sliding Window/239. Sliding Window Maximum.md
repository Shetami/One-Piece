Вам предоставляется массив целых чисел `nums`, есть скользящее окно определенного размера `k`, которое перемещается из самого левого края массива в самый правый. Вы можете видеть только `k` цифры в окне. Каждый раз раздвижное окно перемещается вправо на одну позицию.

Возвращает _максимальное значение раздвижного окна_.

**Example 1:**
```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**
```
Input: nums = [1], k = 1
Output: [1]
```

Для наглядности идеи в качестве примера возьмем такой массив `[1, 1, 1, 1, 1, 4, 5]` и `k = 6`. Найдем максимум, проходимся по нашему окну размером 6 и находим максимум, это 4. Передвигаем окно правее. Находим снова максимум. И нам опять пришлось пройтись по первым 4 единицам, которые не могут быть уже максимумом. И наша задача по оптимизации состоит в том чтоб оптимизировать работу и убрать очевидно ненужные проверки при поиске максимума. Тут нам поможет *Deque*(очередь). Очередь у нас будет всегда убывающая, то есть самой большое значение окна будет находится слева. Проходимся по массиву и получаем следующую очередь: `[1, 1, 1, 1, 1, 4]`. Наш максимум это 4. Фиксируем наш максимум в результат. Все значения слева мы можем удалить и тогда останется только 4. Сдвигаем окно вправо. У нас появляется 5, и нам не нужно еще раз проходить по всему массиву, нам надо сравнить только оставшуюся 4 и 5, 5 > 4 поэтому 4 мы можем удалить, она нам больше не нужна, и кладем в начало очереди нашу 5, она также являясь максимумом отправляется в результирующий массив. Отлично. Но этот пример слишком тривиальный, возьмем наш стандартный массив `[1,3,-1,-3,5,3,6,7], k = 3`. Разберем его графически:
![[Pasted image 20240701232936.png]]
Мы добавляем 1 в очередь, затем у нас идет 3 которое больше, так как очередь у нас убывающая, то мы удаляем первую единицу так как она больше нам не нужна, далее рассматриваем -1, оно меньше нашей 3 поэтому просто добавляем значение -1 в очередь, а 3 записываем в ответ.
![[Pasted image 20240701234015.png]]
Мы дошли до итерации когда 3 выпадает так как она вышла из окна, в очереди только -1 и -3, на вход подается 5, сравниваем `-1 < 5`, так как слева должно быть максимальное значение то -1 мы удаляем, значение за -1 всегда теперь будет меньше 5, удаляем нашу -3 и в очередь кладем 5, таким образом мы проходимся до конца массива. Что дает нам уже выше известный результат.

# Code
- Python
	```python
	class Solution:
	    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
	        result = []
	        l = r = 0
	        q = collections.deque() #index
	        while r < len(nums):
	            # pop smaller values from q
	            while q and nums[q[-1]] < nums[r]:
	                q.pop()
	            q.append(r)
	            #remove left val from window
	            if l > q[0]:
	                q.popleft()
	            
	            if (r + 1) >= k:
	                result.append(nums[q[0]])
	                l += 1
	            r += 1
	        return result
	```

- Go
	```go
	func maxSlidingWindow(nums []int, k int) []int {
	    var result []int
	    l, r := 0, 0
	    q := list.New()
	    for r < len(nums) {
	        // pop smaller values from q
	        for q.Len() > 0 && nums[q.Back().Value.(int)] < nums[r] {
	            q.Remove(q.Back())
	        }
	        q.PushBack(r)
	        // remove left val from window
	        if l > q.Front().Value.(int) {
	            q.Remove(q.Front())
	        }
	        if (r + 1) >= k {
	            result = append(result, nums[q.Front().Value.(int)])
	            l++
	        }
	        r++
	    }
	    return result
	}
	```