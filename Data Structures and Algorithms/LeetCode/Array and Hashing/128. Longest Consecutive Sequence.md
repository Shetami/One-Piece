Учитывая несортированный массив целых чисел, `nums`верните _длину самой длинной последовательной последовательности элементов._

Вы должны написать алгоритм, который выполняется за `O(n)` время.

**Example 1:**
```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Example 2:**
```
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
```

Кажется задача первоклассника. Берем сортируем массив и ищем максимальную подпоследовательность. НО! Нас тут просят сделать это за `O(n)` а сортировка та то работает за `O(nlog)` так что тут не так все однозначно. Представим себе числовую прямую:
![[Pasted image 20240611230138.png]]
Что есть начало подпоследовательности? Начало это это то число у которого нет соседа с лева. Вот как на картинке. 1 не имеет соседа 0, поэтому вполне себе начало а не середина какая ни будь. 100 тоже не имеет соседа слева в виде 99, 200 не имеет слева 199. Вот основной признак и по сути идея задачи. 
Для того чтоб нам не бегать по всему массиву и не искать опять же нужный элемент, как всегда заводим *HashSet* ура-ура. Так мы проходимся по входному массиву `[100,4,200,1,3,2]`:
1) 100 - 99 нет в нашем наборе, счетчик равен 1
2) Пытаемся найти 101, такого нет, значит заканчиваем, счетчик сбрасываем
3) 4 - сосед слева в виде 3 есть, скипаем нас это не волнует по сути
4) 200 - соседа слева нет, счетчик на 1, справа ничего нет, счетчик в 0
5) 1 - слева никого нет, счетчик увеличили на 1
6) Пытаемся найти соседа справа - 2 есть, увеличиваем счетчик на 1
7) Далее 3 - есть еще +1
8) 4 - отлично счетчик еще +1
9) и тд
Вроде все довольно просто, если понять идею про числовую прямую. В общей сложности по каждому элементу мы можем пройтись не более 2х раз, один раз когда мы проверяем на начало последовательности, второй когда данный элемент по сути включен в нее. Вот и наши `O(2n)` экей `O(n)` сложность.

# Code

- Python
	```python
	class Solution: 
		def longestConsecutive(self, nums: List[int]) -> int: 
			num_set = set(nums) 
			longest = 0 
			for n in nums: 
				if (n - 1) not in num_set: 
					length = 0 
					while(n + length) in num_set: 
						length += 1 
					longest = max(longest, length) 
			return longest
	```

- Go
	```Go
	func longestConsecutive(nums []int) int {
	    numSet := make(map[int]struct{})
	    for _, num := range nums {
	        numSet[num] = struct{}{}
	    }
	    longest := 0
	    for _, num := range nums {
	        if _, found := numSet[num-1]; !found {
	            length := 0
	            for {
	                if _, found := numSet[num+length]; !found {
	                    break
	                }
	                length++
	            }
	            if length > longest {
	                longest = length
	            }
	        }
	    }
	    return longest
	}
	```