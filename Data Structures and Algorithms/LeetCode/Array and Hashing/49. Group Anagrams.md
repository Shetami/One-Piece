Получив массив строк `strs`, сгруппируйте анаграммы вместе. Вы можете вернуть ответ в любом порядке.

**Анаграмма** - это слово или фраза, образованные путем перестановки букв другого слова или фразы, обычно все исходные буквы используются ровно один раз.

**Example 1:**

```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

```

**Example 2:**

```
Input: strs = [""]
Output: [[""]]

```

**Example 3:**

```
Input: strs = ["a"]
Output: [["a"]]
```

Для решения данной проблемы мы будем использовать _HashMap_ для группировки слов. Ключом мы возьмем массив где будем хранить количество каждой буквы. А значением будет выступать массив непосредственно со словами подходящими по набору букв из ключа. Тут наверное стоит поподробнее пояснить как будет работать наши ключи.

![[Pasted image 20240609164303.png]]

Мы заведем массив из 26 символов, что будет соответствовать количеству букв Английского алфавита. и так у нас получится что то типа такого на самом деле:

```python
count = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Мы будем увеличивать то значение, индекс которой будет соответствовать позиции символа в таблице _ASCII_ (другими словами в английском алфавите). Но как нам это сделать? И так, в _ASCII_ значение **“a”** у нас равняется 80, все дальнейшие символы по алфавиту будут _80 + n_, и так чтобы нас понять в какой позиции увеличить значение нужно просто от значения n отнять 80.

![[Pasted image 20240609164331.png]]

Подчеркнутые числа и будут индексами соответствующим нужной букве. Надеюсь этот момент мне удалось пояснить.

В итоге для слова **“eat”** у нас получается следующий массив:

```python
count = [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]
```

Как мы видим первая единица это наша **“a”**, под 4 индексом **“e”** и последняя единица **“t”.**

# Code

- Python
    
    ```python
    import collections
    
    class Solution:
        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
            res = collections.defaultdict(list)
            for s in strs:
                count = [0]*26
                for c in s:
                    count[ord(c) - ord("a")] += 1
                res[tuple(count)].append(s)
    
            return res.values()
    ```
    
    Так, немного пояснений. Класс `defaultdict()` модуля `collections` ничем не отличается от обычного словаря за исключением того, что по умолчанию всегда вызывается функция, которая возвращает значение по умолчанию для новых значений. Другими словами Класс `defaultdict()` представляет собой словарь со значениями по умолчанию.
    
    ```python
    count[ord(c) - ord("a")] += 1
    ```
    
    В этой записи `ord(c)` означает что мы переводим значение `c` в представление _ASCII._
    
    Так как в Python списки не могут быть ключами нам надо привести его к кортежу потому что он не изменяем:
    
    ```python
    res[tuple(count)].append(s)
    ```
    
- Go
    
    ```go
    func groupAnagrams(strs []string) [][]string {
    	result := map[string][]string{}
    	for _, str := range strs {
    		charCount := make([]int, 26)
    		for _, char := range str {
    			charCount[char-'a']++
    		}
    		key := string(charCount) // convert charCount slice to string as key
    		result[key] = append(result[key], str)
    	}
    	var groups [][]string
    	for _, value := range result {
    		groups = append(groups, value)
    	}
    	return groups
    }
    ```