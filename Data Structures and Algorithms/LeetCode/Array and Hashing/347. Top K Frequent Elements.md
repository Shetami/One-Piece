Учитывая целочисленный массив `nums` и целое число `k`, верните `k` _наиболее часто встречающиеся элементы_. Вы можете вернуть ответ в **любом порядке**.

**Example 1:**
```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**
```
Input: nums = [1], k = 1
Output: [1]
```

Прикольная задача, так как имеет несколько неплохих решений. Самое первое что мы можем придумать это проход по массиву и подсчет в *HashMap* количества каждого элемента. Затем отсортировать по значению и взять первые `k` элементов. Данное решение рассматривать не буду, может потом опишу его в коде, если не будет впадлу.

А сейчас разберем более интересное решение задачи.
И так у нас есть на входе массив из `n` элементов. Мы создаем второй массив тоже из `n` элементов, где индекс массива, возьмем его за `i`  будет показывать количество элементов в исходном массиве(короче counter), и наши `values` которые будут содержать динамические массивы из значений количество вхождений которых соответствует индексу. Ну и так как несколько элементов может иметь одинаковое количество вхождений, мы их группируем.

![[Pasted image 20240609192648.png]]

И так примерно так все выглядит. И остается только пройти с конца массива и взять последние `k` элементов. Если `values` пустое то скипаем и идем так пока не встретим значения.
Так а че по сложности то а итоге. Все прекрасно она **O(n)**. Давайте разберем худший случай. 
![[Pasted image 20240609193507.png]]
 И так тут мы видим что нам надо пройтись `n` раз по входному массиву чтоб заполнить второй. И нам надо пройти так же `n - 1` раз уже по второму массиву чтоб дойти до нашего значения. и так получается что `O(n + n - 1)` , что эквивалентно `O(n)` Отлично, с духотой закончили теперь идите и смотрите секцию кода.

# Code

- Python

    ```python
    class Solution:
	    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
		     count = {} 
		     freq = [[] for i in range(len(nums) + 1)] 
		     
		     for n in nums: 
			     count[n] = 1 + count.get(n, 0)
			     
			 for n, c in count.items():
			    freq[c].append(n)
			
			res = []
			for i in range(len(freq) - 1, 0, -1):
			    for n in freq[i]: 
				    res.append(n)
				    if len(res) == k:
				        return res
    ```
    
- Go
    
	 ```go
	func topKFrequent(nums []int, k int) []int {
	
	    count := make(map[int]int)
	    freq := make([][]int, len(nums) + 1)
	
	    for n := range nums {
	        count[nums[n]] = 1 + count[nums[n]]
	    }
	    for n, c := range count {
	        freq[c-1] = append(freq[c-1], n)
	    }
	    
	    res := make([]int, 0)
	    for i := len(freq) - 1; i >= 0; i-- {
	        for n := range freq[i] {
	            res = append(res, freq[i][n])
	            if len(res) == k {
	                return res
	            }
	        }
	    }
	    return res
	}
	 ```
