Определите, является ли `9 x 9` доска для судоку допустимой. Только заполненные ячейки должны быть проверены **в соответствии со следующими правилами**:

1. Каждая строка должна содержать цифры `1-9` без повторения.
2. Каждый столбец должен содержать цифры `1-9` без повторения.
3. Каждый из девяти `3 x 3` вложенных блоков таблицы должен содержать цифры `1-9` без повторения.

**Примечание:**

- Доска для судоку (частично заполненная) может быть допустимой, но не обязательно разрешимой.
- Только заполненные ячейки должны быть проверены в соответствии с упомянутыми правилами.

**Example 1:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true
```

**Example 2:**
```
Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```

Первые два пункта задачи в условии довольно просты, самая суть остается в последнем пункте, где от нас требуют в квадрате `3 x 3` проверить наличие дубликатов.
Для проверки наличия дубликатов, как это часто бывает, мы будем использовать набор или по человечески *HashSet*. У нас 3 пункта в задаче. Первые два это просто пройтись по столбцам и строкам проверяя через *HashSet* наличие дубликатов. Сложность самой проверки *HashSet* Составляет **O(1)**, и нам надо пройтись по каждой строке и столбцу, что составит сложность $9^2$ или **O(n^2)**.

Теперь нам надо каким то образом отслеживать значения в контексте ячеек `3 x 3`. И сделаем это следующим образом:
![[Pasted image 20240611214232.png]]
И так мы объединили индексы по группам из 3х значений и присвоили уже индексы для областей `3 x 3`. Допустим у нас есть `9` которая находится под индексами `[4;1]`. Как нам понять в какую конкретно область попадает значение с такими индексами. Мы можем поделить нацело значения индексов на 3 и получить индексы нужной нам области. И так $4/3=1$, а $1/3=0$. Мы получили значения `[0;1]` что соответствует положению нашей области. В итоге мы заводим *HashMap* где **key** будет у нас `[rows/3; cols/3]` а **value** будет *HashSet* со значениями. Что мы имеем в итоге:
- cols  *HashSet* - для проверки столбцов
- rows  *HashSet* - для проверки строк
- squares *HashSet* - для проверки значений в пределе квадрата `3 x 3`
Остается только пройтись по всей таблице и проверить данные условия.

# Code

- Python
	```python
	class Solution: 
		def isValidSudoku(self, board: List[List[str]]) -> bool: 
			cols = collections.defaultdict(set) 
			rows = collections.defaultdict(set) 
			squares = collections.defaultdict(set) 
			for i in range(9): 
				for j in range(9): 
					if board[i][j] == ".": 
						continue 
					if ( board[i][j] in rows[i] 
					or board[i][j] in cols[j] 
					or board[i][j] in squares[(i // 3, j // 3)] ): 
						return False 
					cols[j].add(board[i][j]) 
					rows[i].add(board[i][j]) 
					squares[(i//3, j//3)].add(board[i][j]) 
			return True
	```

- Go
	```Go
	func isValidSudoku(board [][]byte) bool {
	    rows := make([]map[byte]bool, 9)
	    cols := make([]map[byte]bool, 9)
	    squares := make([]map[byte]bool, 9)
	
	    for i := 0; i < 9; i++ {
	        rows[i] = make(map[byte]bool)
	        cols[i] = make(map[byte]bool)
	        squares[i] = make(map[byte]bool)
	    }
	
	    for i := 0; i < 9; i++ {
	        for j := 0; j < 9; j++ {
	            if board[i][j] == '.' {
	                continue
	            }
	            num := board[i][j]
	            squareIndex := (i/3)*3 + j/3
	            if rows[i][num] || cols[j][num] || squares[squareIndex][num] {
	                return false
	            }
	
	            rows[i][num] = true
	            cols[j][num] = true
	            squares[squareIndex][num] = true
	        }
	    }
	    return true
	}
	```