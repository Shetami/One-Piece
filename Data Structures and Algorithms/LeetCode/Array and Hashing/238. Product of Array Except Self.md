Учитывая целочисленный массив `nums`, верните _массив_ `answer` _такой,_ _что_`answer[i]` _равно произведению всех элементов_  `nums`, за исключением `nums[i]`.

Произведение любого префикса или суффикса `nums` **гарантированно** укладывается в **32-разрядное** целое число.

Вы должны написать алгоритм, который выполняется за `O(n)` время и без использования операции деления.

**Example 1:**
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Example 2:**
```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

По умолчанию данная задача не кажется сложной, но нам дают условие что это должно работать за `O(n)` так еще и без операции деления. По сути данная задача сводится идее [префиксной суммы](https://en.wikipedia.org/wiki/Prefix_sum).  Но в нашей ситуации скорее префиксное произведение и постфиксное произведение. 
![[Pasted image 20240609223042.png]]
И на выходе нам надо перемножить левый префикс и правый постфикс для получения нужного значения.
![[Pasted image 20240609235424.png]]
Как выделено зеленым, пограничные значения мы берем за 1. И далее перемножая соседние индексы массивов *prefix* и *postfix*. 

Отлично. Но если приглядеться, то можно заметить что нам не особо нужны два дополнительных массива для сохранения *prefix* и *postfix*. Мы можем записывать результат сразу в итоговый массив.
![[Pasted image 20240610001734.png]]
В переменную мы сохраняем наш текущий *prefix*. По умолчанию мы ставим значение 1. Затем мы умножаем значение *prefix* на текущее значение массива, то есть на 1. Записываем значение префикса в следующую позицию. То есть снова 1. Умножаем значение *prefix* на на текущее значение массива получаем 2, и Так вплоть до конца.
Теперь мы проходимся так же в обратную сторону с *postfix*, но теперь мы не просто записываем значение а ячейку, а умножаем на текущее и получаем результат. 

# Code
- Python
	```python
	class Solution:
		def productExceptSelf(self, nums: List[int]) -> List[int]: 
			res = [1] * (len(nums)) 
			prefix = 1 
			for i in range(len(nums)): 
				res[i] = prefix 
				prefix *= nums[i] 
				
			postfix = 1 
			for i in range(len(nums) -1, -1, -1): 
				res[i] *= postfix 
				postfix *= nums[i]
			 return res
    ```
- Go
	```Go
	func productExceptSelf(nums []int) []int {
	    res := make([]int, len(nums))
	    for i := range res{
	        res[i] = 1
	    }
	    
	    prefix := 1
	    for i := 0; i < len(nums); i++{
	        res[i] = prefix
	        prefix *= nums[i]
	    }
	
	    postfix := 1
	    for i := len(nums) - 1; i >= 0; i--{
	        res[i] *= postfix
	        postfix *= nums[i]
	    }
	    return res
	}
	```