Вам будет предоставлен массив целых чисел `height` длины `n`. Здесь `n` нарисованы вертикальные линии таким образом, что двумя конечными точками `ith` линии являются `(i, 0)` и `(i, height[i])`.

Найдите две линии, которые вместе с осью x образуют контейнер таким образом, чтобы в контейнере было больше всего воды.

Возвращайте _максимальное количество воды, которое может вместить емкость_.

**Обратите** внимание, что нельзя наклонять емкость.

**Example 1:**
![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**
```
Input: height = [1,1]
Output: 1
```

Хорошая задача под метод *Two Pointers*. Тут нам требуется как и в большинстве случаев начать движение с обоих сторон. 
Мы начинаем сравнивать площадь: указатель L стоит на на 1, указатель R на 7. Как нам определить до какого момента мы можем заполнить емкость? Мы смотрим на минимальный бортик нашей емкости. 1 < 7, поэтому в высоту мы можем налить лишь до значения 1. В ширину наша емкость равна 8. И того площадь равна $S=1*8=8$ . 
![[Pasted image 20240618124217.png]]
Как нам увеличить объем? Логично что нам надо чтоб минимальный бортик стал выше. Мы можем сдвинуть указатель L на следующее значение. Теперь значение L = 8, а R = 7. Ширина емкости стала на 1 единицу меньше, но зато минимальная высота бортика значительно выросла:
![[Pasted image 20240618124651.png]]
Таким образом считая площадь емкости $S=7*7=49$ . Отлично, как раз это значение в данном примере и является максимальным. Так мы проходим по всему массиву пока наши указатели не встретятся. Сравниваем два значения указателей, меньшее из них умножаем на расстояние между указателями, сравниваем с текущим максимумом нашу площадь, двигаем указатель меньшего бортика. 

# Code

- Python
	```python
	class Solution: 
		def maxArea(self, height: List[int]) -> int: 
			i = 0 
			j = len(height) - 1 
			maximum = 0 
			while j > i: 
				cur = (j - i)*(min(height[i],height[j])) 
				maximum = max(maximum, cur) 
				if height[i] > height[j]: 
					j -= 1
				else: 
					i += 1 
			return maximum
	```

- Go
	```go
	func maxArea(height []int) int {
		i := 0
		j := len(height) - 1
		maximum := 0
		for j > i {
			cur := (j - i) * min(height[i], height[j])
			if cur > maximum {
				maximum = cur
			}
			if height[i] > height[j] {
				j--
			} else {
				i++
			}
		}
		return maximum
	}
	```